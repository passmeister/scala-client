/**
 * Demo Client for Passmeister Apple Wallet and Google Wallet API
 * [www.passmeister.com](https://www.passmeister.com).
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import java.text.SimpleDateFormat

import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class PassApi(
  val defBasePath: String = "https://localhost",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new PassApiAsyncHelper(client, config)

  /**
   * This method creates or (if the pass id already exists) updates a pass, so you don&#39;t have to track ids and creation status of your passes.
   * This method creates or (if the pass id already exists) updates a pass, so you don&#39;t have to track ids and creation status of your passes.
   *
   * @param passTypeId your pass type id, for example P963493 (Urban Fitness) 
   * @param passId id of the pass (provided by you when creating the pass or automatically set by passmeister) (optional)
   * @return void
   */
  def createOrUpdatePass(passTypeId: Any, passId: Option[Any] = None) = {
    val await = Try(Await.result(createOrUpdatePassAsync(passTypeId, passId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * This method creates or (if the pass id already exists) updates a pass, so you don&#39;t have to track ids and creation status of your passes. asynchronously
   * This method creates or (if the pass id already exists) updates a pass, so you don&#39;t have to track ids and creation status of your passes.
   *
   * @param passTypeId your pass type id, for example P963493 (Urban Fitness) 
   * @param passId id of the pass (provided by you when creating the pass or automatically set by passmeister) (optional)
   * @return Future(void)
   */
  def createOrUpdatePassAsync(passTypeId: Any, passId: Option[Any] = None) = {
      helper.createOrUpdatePass(passTypeId, passId)
  }

  /**
   * Delete pass by pass id.
   * Delete pass by pass id.
   *
   * @param passTypeId your pass type id, for example P963493 (Urban Fitness) 
   * @param passId id of the pass 
   * @return void
   */
  def deletePass(passTypeId: Any, passId: Any) = {
    val await = Try(Await.result(deletePassAsync(passTypeId, passId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete pass by pass id. asynchronously
   * Delete pass by pass id.
   *
   * @param passTypeId your pass type id, for example P963493 (Urban Fitness) 
   * @param passId id of the pass 
   * @return Future(void)
   */
  def deletePassAsync(passTypeId: Any, passId: Any) = {
      helper.deletePass(passTypeId, passId)
  }

  /**
   * Get pass information by pass id.
   * Get pass information by pass id.
   *
   * @param passTypeId your pass type id, for example P963493 (Urban Fitness) 
   * @param passId id of the pass 
   * @return void
   */
  def getPass(passTypeId: Any, passId: Any) = {
    val await = Try(Await.result(getPassAsync(passTypeId, passId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get pass information by pass id. asynchronously
   * Get pass information by pass id.
   *
   * @param passTypeId your pass type id, for example P963493 (Urban Fitness) 
   * @param passId id of the pass 
   * @return Future(void)
   */
  def getPassAsync(passTypeId: Any, passId: Any) = {
      helper.getPass(passTypeId, passId)
  }

  /**
   * Retrieve the list of active pass ids for a given pass type.
   * Retrieve the list of active pass ids for a given pass type.
   *
   * @param passTypeId your pass type id, for example P963493 (Urban Fitness) 
   * @param page  (optional)
   * @param limit  (optional)
   * @return void
   */
  def passList(passTypeId: Any, page: Option[Any] = None, limit: Option[Any] = None) = {
    val await = Try(Await.result(passListAsync(passTypeId, page, limit), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Retrieve the list of active pass ids for a given pass type. asynchronously
   * Retrieve the list of active pass ids for a given pass type.
   *
   * @param passTypeId your pass type id, for example P963493 (Urban Fitness) 
   * @param page  (optional)
   * @param limit  (optional)
   * @return Future(void)
   */
  def passListAsync(passTypeId: Any, page: Option[Any] = None, limit: Option[Any] = None) = {
      helper.passList(passTypeId, page, limit)
  }

  /**
   * Send updates to all active passes for a given pass type.
   * For example: you changed the pass type layout and now you want to update all installed passes. (The API call only confirms the scheduling of the updates, actual updating of passes on your customers devices can take a while.)
   *
   * @param passTypeId your pass type id, for example P963493 (Urban Fitness) 
   * @return void
   */
  def passSync(passTypeId: Any) = {
    val await = Try(Await.result(passSyncAsync(passTypeId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Send updates to all active passes for a given pass type. asynchronously
   * For example: you changed the pass type layout and now you want to update all installed passes. (The API call only confirms the scheduling of the updates, actual updating of passes on your customers devices can take a while.)
   *
   * @param passTypeId your pass type id, for example P963493 (Urban Fitness) 
   * @return Future(void)
   */
  def passSyncAsync(passTypeId: Any) = {
      helper.passSync(passTypeId)
  }

}

class PassApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def createOrUpdatePass(passTypeId: Any,
    passId: Option[Any] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/pass"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (passTypeId == null) throw new Exception("Missing required parameter 'passTypeId' when calling PassApi->createOrUpdatePass")
    queryParams += "passTypeId" -> passTypeId.toString
    passId match {
      case Some(param) => queryParams += "passId" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deletePass(passTypeId: Any,
    passId: Any)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/pass"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (passTypeId == null) throw new Exception("Missing required parameter 'passTypeId' when calling PassApi->deletePass")
    if (passId == null) throw new Exception("Missing required parameter 'passId' when calling PassApi->deletePass")
    queryParams += "passTypeId" -> passTypeId.toString
    queryParams += "passId" -> passId.toString

    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getPass(passTypeId: Any,
    passId: Any)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/pass"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (passTypeId == null) throw new Exception("Missing required parameter 'passTypeId' when calling PassApi->getPass")
    if (passId == null) throw new Exception("Missing required parameter 'passId' when calling PassApi->getPass")
    queryParams += "passTypeId" -> passTypeId.toString
    queryParams += "passId" -> passId.toString

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def passList(passTypeId: Any,
    page: Option[Any] = None,
    limit: Option[Any] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/pass/list"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (passTypeId == null) throw new Exception("Missing required parameter 'passTypeId' when calling PassApi->passList")
    queryParams += "passTypeId" -> passTypeId.toString
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    limit match {
      case Some(param) => queryParams += "limit" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def passSync(passTypeId: Any)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/pass/sync"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (passTypeId == null) throw new Exception("Missing required parameter 'passTypeId' when calling PassApi->passSync")
    queryParams += "passTypeId" -> passTypeId.toString

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
